#!/bin/sh
# Low-level HTTP caller for Topdesk API
set -eu

_this="$0"; _dir=${_this%/*}; _root=${_dir%/tools}
. "$_root/lib/common.sh"; . "$_root/lib/log.sh"; . "$_root/lib/args.sh"; . "$_root/lib/config.sh"

TIMEOUT_DEFAULT=${TDX_TIMEOUT:-30}
RETRY_DEFAULT=${TDX_RETRY:-0}
RETRY_DELAY_DEFAULT=${TDX_RETRY_DELAY:-0}

usage() {
  cat <<EOF
Usage: ${TOOLBOX_NAME} call <METHOD> <PATH> [options]

Perform an HTTP request to Topdesk API. PATH is appended to TDX_BASE_URL.

Options:
  -h, --help            Show help
  -d, --data JSON|@FILE Send JSON request body (POST/PUT/PATCH)
  -H, --header H        Add extra header (can repeat)
  --accept TYPE         Accept header (default: application/json)
  --content TYPE        Content-Type header (default: application/json)
  --query QS            Query string to append (e.g. "a=b&c=d")
  --param KEY=VAL       Add query parameter (can repeat; also accepts "--param KEY VAL")
  --timeout SEC         Override timeout (default: $TIMEOUT_DEFAULT)
  --retry N             Retry count (default: $RETRY_DEFAULT)
  --retry-delay SEC     Retry delay seconds (default: $RETRY_DELAY_DEFAULT)
  --cacert FILE         CA certificate file
  --capath DIR          CA directory
  --insecure            Do not verify TLS (curl -k)
  --raw                 Print raw response (no pretty printing)
  --pretty              Pretty-print JSON via jq if available
  --output FILE         Write response body to FILE (suppresses stdout)
  --tee FILE            Write body to FILE and still emit to stdout
  --dry-run             Print the constructed curl command and exit

Environment/config:
  TDX_BASE_URL   Base URL, e.g. https://topdesk.example.com
  TDX_USER       Username for Basic auth (optional)
  TDX_PASS       Password for Basic auth (optional)
  TDX_AUTH_HEADER Custom header, e.g. "Authorization: Bearer <token>"
  TDX_VERIFY_TLS  1 (default) or 0 to skip verification
  TDX_TIMEOUT     Default timeout (seconds)
EOF
}

shell_quote() {
  case ${1-} in
    "") printf "''" ;;
    *[!A-Za-z0-9_./-]*) printf "'%s'" "$(printf '%s' "$1" | sed "s/'/'\\''/g")" ;;
    *) printf '%s' "$1" ;;
  esac
}

print_curl_command() {
  printf 'curl'
  for arg in "$@"; do
    printf ' %s' "$(shell_quote "$arg")"
  done
  printf '\n'
}

build_curl_command() {
  target=$1
  headers_out=$2
  shift 2 || true
  CURL_CMD=""
  append_arg() {
    if [ -n "$CURL_CMD" ]; then
      CURL_CMD="$CURL_CMD
$1"
    else
      CURL_CMD="$1"
    fi
  }
  append_arg -sS
  append_arg --connect-timeout
  append_arg "$TIMEOUT"
  append_arg --max-time
  append_arg "$TIMEOUT"
  append_arg -X
  append_arg "$METHOD"
  [ "${INSECURE}" = 1 ] && append_arg -k
  if [ "$RETRY" -gt 0 ] 2>/dev/null; then
    append_arg --retry
    append_arg "$RETRY"
    append_arg --retry-all-errors
    if [ "$RETRY_DELAY" -gt 0 ] 2>/dev/null; then
      append_arg --retry-delay
      append_arg "$RETRY_DELAY"
    fi
  fi
  [ -n "$CACERT" ] && { append_arg --cacert; append_arg "$CACERT"; }
  [ -n "$CAPATH" ] && { append_arg --capath; append_arg "$CAPATH"; }
  append_arg -H
  append_arg "Accept: $ACCEPT"
  case "$METHOD" in
    POST|PUT|PATCH)
      append_arg -H
      append_arg "Content-Type: $CONTENT"
      ;;
  esac
  if [ -n "${TDX_AUTH_HEADER:-}" ]; then
    append_arg -H
    append_arg "$TDX_AUTH_HEADER"
  elif [ -n "${TDX_AUTH_TOKEN:-}" ]; then
    append_arg -H
    append_arg "Authorization: ${TDX_AUTH_TOKEN}"
  elif [ -n "${TDX_USER:-}" ] || [ -n "${TDX_PASS:-}" ]; then
    append_arg -u
    append_arg "${TDX_USER:-}:${TDX_PASS:-}"
  fi
  if [ -n "$HEADERS" ]; then
    while IFS= read -r h; do
      [ -n "$h" ] || continue
      append_arg -H
      append_arg "$h"
    done <<EOF
$HEADERS
EOF
  fi
  if [ -n "$DATA" ]; then
    case "$DATA" in
      @*) append_arg --data-binary; append_arg "$DATA" ;;
      *) append_arg --data; append_arg "$DATA" ;;
    esac
  fi
  append_arg --dump-header
  append_arg "$headers_out"
  append_arg -o
  append_arg "$target"
}

[ "$#" -ge 1 ] || { usage >&2; exit 2; }
case ${1:-} in -h|--help) usage; exit 0;; esac

DATA=""; ACCEPT="application/json"; CONTENT="application/json"
TIMEOUT=${TDX_TIMEOUT:-30}; INSECURE=0; RAW=0; PRETTY=0; QUERY=""; HEADERS=""; PARAMS=""
RETRY=${TDX_RETRY:-0}; RETRY_DELAY=${TDX_RETRY_DELAY:-0}; CACERT=""; CAPATH=""; OUTPUT=""; TEE=""; DRY_RUN=0

METHOD=""
while [ "$#" -gt 0 ]; do
  case "$1" in
    -h|--help) usage; exit 0 ;;
    --dry-run) DRY_RUN=1; shift; continue ;;
    --output) req_arg "$@"; OUTPUT=$2; shift 2; continue ;;
    --tee) req_arg "$@"; TEE=$2; shift 2; continue ;;
    --) shift; break ;;
    -*) break ;;
    *) METHOD=$1; shift; break ;;
  esac
done

if [ -z "$METHOD" ]; then
  [ "$#" -gt 0 ] || { err "missing METHOD"; usage >&2; exit 2; }
  METHOD=$1; shift
fi

PATH_IN=${1:-}
[ -n "$PATH_IN" ] || { err "missing PATH"; usage >&2; exit 2; }
shift || true

while [ "$#" -gt 0 ]; do
  case "$1" in
    -h|--help) usage; exit 0 ;;
    -d|--data) req_arg "$@"; DATA=$2; shift 2 ;;
    -H|--header) req_arg "$@"; HEADERS="$HEADERS\n$2"; shift 2 ;;
    --accept) req_arg "$@"; ACCEPT=$2; shift 2 ;;
    --content) req_arg "$@"; CONTENT=$2; shift 2 ;;
    --query) req_arg "$@"; QUERY=$2; shift 2 ;;
    --param)
      req_arg "$@"
      args_take_param "$2" "${3-}" --param
      args_params_append PARAMS "$ARGS_PARAM_KEY" "$ARGS_PARAM_VAL"
      shift 2
      [ "$ARGS_PARAM_SHIFT" -eq 1 ] && shift
      ;;
    --param=*)
      args_take_param "${1#--param=}" "" --param
      args_params_append PARAMS "$ARGS_PARAM_KEY" "$ARGS_PARAM_VAL"
      shift
      ;;
    --timeout) req_arg "$@"; TIMEOUT=$2; shift 2 ;;
    --insecure) INSECURE=1; shift ;;
    --retry) req_arg "$@"; RETRY=$2; shift 2 ;;
    --retry-delay) req_arg "$@"; RETRY_DELAY=$2; shift 2 ;;
    --cacert) req_arg "$@"; CACERT=$2; shift 2 ;;
    --capath) req_arg "$@"; CAPATH=$2; shift 2 ;;
    --output) req_arg "$@"; OUTPUT=$2; shift 2 ;;
    --tee) req_arg "$@"; TEE=$2; shift 2 ;;
    --dry-run) DRY_RUN=1; shift ;;
    --raw) RAW=1; shift ;;
    --pretty) PRETTY=1; shift ;;
    --) shift; break ;;
    -*) err "unknown option: %s" "$1"; usage >&2; exit 2 ;;
    *) break ;;
  esac
done

[ -n "${TDX_BASE_URL:-}" ] || { err "TDX_BASE_URL not set"; exit 2; }

if [ -n "$OUTPUT" ] && [ -n "$TEE" ]; then
  err "--output cannot be combined with --tee"; exit 2
fi
if [ -n "$OUTPUT" ] && [ "$PRETTY" = 1 ]; then
  err "--pretty cannot be used with --output; use --tee for stdout"; exit 2
fi

if [ -n "$PARAMS" ]; then
  while IFS= read -r pair; do
    [ -n "$pair" ] || continue
    key=${pair%%=*}
    val=${pair#*=}
    QUERY=$(query_add "$QUERY" "$key" "$val")
  done <<EOF
$PARAMS
EOF
fi

# Respect TDX_VERIFY_TLS=0 unless overridden by --insecure flag
if [ "${INSECURE}" = 0 ] && [ "${TDX_VERIFY_TLS:-1}" = 0 ]; then
  INSECURE=1
fi

# Build URL
base=${TDX_BASE_URL%/}
path=/$(printf '%s' "$PATH_IN" | sed 's/^\/*//')
[ -n "$QUERY" ] && qs="?$QUERY" || qs=""
url="$base$path$qs"
CAPTURE_BODY=1
if [ -n "$OUTPUT" ] && [ -z "$TEE" ]; then
  CAPTURE_BODY=0
fi

body_preview=$OUTPUT
[ "$CAPTURE_BODY" -eq 1 ] && body_preview="${TMPDIR:-/tmp}/topdesk-call-body.preview"
headers_preview=/dev/null

build_curl_command "$body_preview" "$headers_preview"

set --
if [ -n "$CURL_CMD" ]; then
  while IFS= read -r arg; do
    set -- "$@" "$arg"
  done <<EOF
$CURL_CMD
EOF
fi

if [ "$DRY_RUN" -eq 1 ]; then
  print_curl_command "$@" -- "$url"
  exit 0
fi

tmp_body=""
if [ "$CAPTURE_BODY" -eq 1 ]; then
  tmp_body=$(mktemp "${TMPDIR:-/tmp}/topdesk-call-body.XXXXXX") || exit 1
  body_target=$tmp_body
else
  body_target=$OUTPUT
fi
tmp_headers=$(mktemp "${TMPDIR:-/tmp}/topdesk-call-headers.XXXXXX") || { [ -n "$tmp_body" ] && rm -f "$tmp_body"; exit 1; }
cleanup() {
  if [ "$CAPTURE_BODY" -eq 1 ] && [ -n "$tmp_body" ]; then rm -f "$tmp_body"; fi
  [ -n "$tmp_headers" ] && rm -f "$tmp_headers"
}
trap cleanup EXIT INT TERM HUP

build_curl_command "$body_target" "$tmp_headers"

set --
if [ -n "$CURL_CMD" ]; then
  while IFS= read -r arg; do
    set -- "$@" "$arg"
  done <<EOF
$CURL_CMD
EOF
fi

set +e
http_code=$(curl "$@" -w '%{http_code}' -- "$url")
curl_status=$?
set -e

BODY_PATH=$tmp_body
[ "$CAPTURE_BODY" -eq 0 ] && BODY_PATH=$OUTPUT

if [ "$curl_status" -ne 0 ]; then
  case "$curl_status" in
    6) err "request failed: could not resolve host (curl %s)" "$curl_status" ;;
    7) err "request failed: connection refused (curl %s)" "$curl_status" ;;
    28) err "request timed out after %s seconds" "$TIMEOUT" ;;
    *) err "request failed with curl exit %s" "$curl_status" ;;
  esac
  if [ -n "$BODY_PATH" ] && [ -f "$BODY_PATH" ] && [ -s "$BODY_PATH" ]; then
    note "response: %s" "$(head -c 400 "$BODY_PATH" | tr '\r' ' ' )"
  fi
  exit 3
fi

status_line=$(sed -n '1p' "$tmp_headers" | tr -d '\r')
status_reason=${status_line#* }
status_reason=${status_reason#${http_code}}
status_reason=$(printf '%s' "$status_reason" | sed 's/^ *//')

case "$http_code" in
  2??|204)
    :
    ;;
  "")
    err "request completed without HTTP status"
    exit 3
    ;;
  *)
    err "HTTP %s %s" "$http_code" "$status_reason"
    if [ -n "$BODY_PATH" ] && [ -f "$BODY_PATH" ] && [ -s "$BODY_PATH" ]; then
      snippet=$(head -c 600 "$BODY_PATH" | tr '\r' ' ')
      note "response body: %s" "$snippet"
    fi
    case "$http_code" in
      4??) exit 4 ;;
      5??) exit 5 ;;
      *) exit 6 ;;
    esac
    ;;
esac

if [ "$CAPTURE_BODY" -eq 0 ]; then
  exit 0
fi

if [ -n "$TEE" ]; then
  cat "$tmp_body" > "$TEE"
fi

if [ "$RAW" = 1 ]; then
  cat "$tmp_body"
else
  if [ "$PRETTY" = 1 ] && command_exists jq && [ -s "$tmp_body" ]; then
    jq . "$tmp_body"
  else
    cat "$tmp_body"
  fi
fi
